// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include "save_client/Save.h"
#include "match_server/Match.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include<iostream>
#include<thread>
#include<queue>
#include<mutex>//锁
#include<condition_variable>//条件变量，对锁进行封装
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace  ::match_service;
using namespace ::save_service;
using namespace std;
struct Task{
	User user;
	string type;
};
struct MessageQueue{
	queue<Task> q;
	mutex m;
	condition_variable cv;
}message_queue;
class Pool{
	public:
		void add(User user){
			users.push_back(user);
		}
		void remove(User user){
			for(uint32_t i=0;i<users.size();i++){
				if(users[i].id==user.id){
					users.erase(users.begin()+i);
					break;
				}
			}
		}
		void match(){
			while(users.size()>1){
				auto a=users[0],b=users[1];
				users.erase(users.begin());
				users.erase(users.begin());
                save_result(a.id,b.id);
			}
		}
		void save_result(int a,int b){
			printf("Match result:%d %d\n",a,b);
			std::shared_ptr<TTransport> socket(new TSocket("123.57.67.128", 9090));
			std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
			std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
			SaveClient client(protocol);

			try {
				transport->open();
				client.save_data("acs_9452", "6bae7bda", a, b);
				transport->close();
			} catch (TException& tx) {
				cout << "ERROR: " << tx.what() << endl;
			} 
		}
	private:
		vector<User> users;
}pool;
class MatchHandler : virtual public MatchIf {
	public:
		MatchHandler() {
			// Your initialization goes here
		}

		int32_t add_user(const User& user, const std::string& info) {
			// Your implementation goes here
			printf("add_user\n");
			unique_lock<mutex> lck(message_queue.m);
			message_queue.q.push({user,"add"});
			message_queue.cv.notify_all();//唤醒线程
			return 0;
		}

		int32_t remove_user(const User& user, const std::string& info) {
			// Your implementation goes here
			printf("remove_user\n");
			unique_lock<mutex> lck(message_queue.m);
			message_queue.q.push({user,"remove"});
			message_queue.cv.notify_all();
			return 0;
		}

};
//消费者模型
void consume_task()
{
	while(true){
		unique_lock<mutex> lck(message_queue.m);
		if(message_queue.q.empty()){
			message_queue.cv.wait(lck);//wait会释放锁
		}else{
			auto task=message_queue.q.front();
			message_queue.q.pop();
			lck.unlock();
			//do task
			if(task.type=="add")
				pool.add(task.user);
			else if(task.type=="remove")
				pool.remove(task.user);
			pool.match();
		}
	}
}

int main(int argc, char **argv) {
	int port = 9090;
	::std::shared_ptr<MatchHandler> handler(new MatchHandler());
	::std::shared_ptr<TProcessor> processor(new MatchProcessor(handler));
	::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	cout<<1111<<endl;
	//开启线程
	thread matching_thread(consume_task);
	server.serve();

	return 0;
}

